# Tools
## Codegen

!!! warning
    This tool is under development, new features will be added later

    If for some reason you do not want to use this library in your projects, then you can
    generate code


```python
from scrape_schema import BaseSchema, Parsel, Sc
from scrape_schema.codegen import generate_code


class Schema(BaseSchema):
    text: Sc[str, Parsel().css("h1::text").get()]
    words: Sc[list[str], Parsel().xpath("//h1/text()").re(r"\w+")]
    urls: Sc[list[str], Parsel().css("ul > li").xpath(".//@href").getall()]
    sample_jmespath_1: Sc[str, Parsel().css("script::text").jmespath("a").get()]
    sample_jmespath_2: Sc[
        list[str], Parsel().css("script::text").jmespath("a").getall()
    ]


print(generate_code(Schema))
```

Output:

```python
# Created by scrape-schema codegen
#
# WARNING: Any manual changes made to this file will be lost when generator is
# run again.  Do not edit this file unless you know what you are doing.

from typing import Dict, Union, Any
import re

from parsel import Selector, SelectorList
import chompjs


class Schema:
    def __init__(self):
        self.__scope: Dict[str, Any] = {}

    @staticmethod
    def _prepare_markup(markup: Union[str, bytes, Selector, SelectorList]):
        if isinstance(markup, str):
            return Selector(markup)
        elif isinstance(markup, bytes):
            return Selector(body=markup)
        elif isinstance(markup, (Selector, SelectorList)):
            return markup
        msg = (f'markup should be [str, bytes, Selector, SelectorList], '
               f'not {type(markup).__name__}')
        raise TypeError(msg)

    def parse(self, markup: Union[str, bytes, Selector, SelectorList]) -> Dict[str, Any]:
        markup = self._prepare_markup(markup)
        return {
            'text': self.__parse_text(markup),
            'words': self.__parse_words(markup),
            'urls': self.__parse_urls(markup),
            'sample_jmespath_1': self.__parse_sample_jmespath_1(markup),
            'sample_jmespath_2': self.__parse_sample_jmespath_2(markup),
            }

    @property
    def cache(self) -> Dict[str, Any]:
        """get last parsed data"""
        return self.__scope

    def __parse_text(self, markup: Union[Selector, SelectorList]) -> Any:
        """Parsel(auto_type=True, default=Ellipsis, alias=None).css('h1::text').get() signature"""
        name = 'text'
        default = ...
        try:
            result = markup.css('h1::text')
            result = result.get()
        except Exception as exc:
            if default is Ellipsis:
                raise exc
            result = default
        self.__scope[name] = result
        return result

    def __parse_words(self, markup: Union[Selector, SelectorList]) -> Any:
        """Parsel(auto_type=True, default=Ellipsis, alias=None).xpath('//h1/text()').re('\\w+', True) signature"""
        name = 'words'
        default = ...
        try:
            result = markup.xpath('//h1/text()')
            result = result.re(r'\w+', True)
        except Exception as exc:
            if default is Ellipsis:
                raise exc
            result = default
        self.__scope[name] = result
        return result

    def __parse_urls(self, markup: Union[Selector, SelectorList]) -> Any:
        """Parsel(auto_type=True, default=Ellipsis, alias=None).css('ul > li').xpath('.//@href').getall() signature"""
        name = 'urls'
        default = ...
        try:
            result = markup.css('ul > li')
            result = result.xpath('.//@href')
            result = result.getall()
        except Exception as exc:
            if default is Ellipsis:
                raise exc
            result = default
        self.__scope[name] = result
        return result

    def __parse_sample_jmespath_1(self, markup: Union[Selector, SelectorList]) -> Any:
        """Parsel(auto_type=True, default=Ellipsis, alias=None).css('script::text').jmespath('a').get() signature"""
        name = 'sample_jmespath_1'
        default = ...
        try:
            result = markup.css('script::text')
            result = result.jmespath('a')
            result = result.get()
        except Exception as exc:
            if default is Ellipsis:
                raise exc
            result = default
        self.__scope[name] = result
        return result

    def __parse_sample_jmespath_2(self, markup: Union[Selector, SelectorList]) -> Any:
        """Parsel(auto_type=True, default=Ellipsis, alias=None).css('script::text').jmespath('a').getall() signature"""
        name = 'sample_jmespath_2'
        default = ...
        try:
            result = markup.css('script::text')
            result = result.jmespath('a')
            result = result.getall()
        except Exception as exc:
            if default is Ellipsis:
                raise exc
            result = default
        self.__scope[name] = result
        return result
```

### Roadmap
- [x] base codegen
- [x] dict serialize
- [ ] dataclass serialize
- [ ] pydantic serialize
- [ ] attrs serialize
- [ ] codegen output optimizations
